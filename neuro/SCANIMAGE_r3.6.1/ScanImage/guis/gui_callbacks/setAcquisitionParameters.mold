function setAcquisitionParameters()
%% function setAcquisitionParameters
%   Parses/adjusts the acquisition parameters set in the Configuration gui(s)
%
%% NOTES
%       DEPRECATED: Rewritten from scratch and renamed to updateAcquisitionParameters() -- Vijay Iyer 1/21/09
%   
%       This function, as of ScanImage 3.0, hard-coded the input and output rates and hard-coded the fillFraction and msPerLine true values
%           for each nominal msPerLine setting
%
%       The logic of the original version seems to be the following (as seen by Vijay Iyer):
%           1. Establish hard-coded AO and AI rates of 40kHz and 1.25MHz, respectively
%           2. Establish that there are 1K/2K/4K/8K samples/line for the 1,2,4,8ms/line cases -- this allows clean divisibility for the 2^x pixels/line (e.g. 128,256,512)
%           3. Compute the fixed "active" line period (# of samples*80ns AI period) to use for each scan speed: .8192/1.6384/3.2768/6.5536 ms/line, respectively
%           4. Observe that periods that are multiples of 100us allow both clock periods (80ns and 25us) to be integer submultiples
%           5. For the 2ms/line case, increment/decrement the "full" line period by increments of 100us (e.g. to 1.9,2.1ms). With fixed "useful" line period, the fill fraction is recomputed.
%           6. For the 1/4/8 ms/line cases, do the same, but increment/decrement the line period by incremetns of 50/200/400us, so that the same fill fraction options are presented to user.
%           7. Disallow any high fill fractions that cause the "true" line period to be longer than the "useful" period by < 100us, which is the default line delay parameter
%           
%           One problem with original version--the 50us increments in line period for the 1ms/line case do not allow for synced AI/AO with the existing clock rate.
%
%
%% CHANGES
%   VI022508A Vijay Iyer 2/25/08 -- Complete rewrite which encodes the logic of the original function (with some correction), rather than hard-coding each of the cases
%   VI031208A Vijay Iyer 3/12/08 -- Add in case of 0.5ms/line and exclude fast scans when not bidirectional scanning
%   VI031308A Vijay Iyer 3/13/08 -- Handle fill fraction checking differently between bidirectional and unidirectional scanning cases
%   VI031308B Vijay Iyer 3/14/08 -- Switch to 50kHz output rate, and adjust/add fill frac values
%   VI031708A Vijay Iyer 3/17/08 -- Adjust linePeriod increment in a scan-speed-dependent fashion, so actual fillFrac values are near to those indicated by GUI values
%   VI091808A Vijay Iyer 9/18/08 -- Eliminate lineDelay/fillFraction connection in this function; this is all handled elsewhere now 
%   VI092408A Vijay Iyer 9/24/08 -- Add nominal fill fraction computation and GUI update
%   VI092808A Vijay Iyer 9/28/08 -- Store number of positive slope points associated with each fill fraction; this will be used by makeSawtoothX()
%   VI120908A Vijay Iyer 12/09/08 -- Correct absolute value handling in testing for integerness
%   VI121008A Vijay Iyer 12/10/08 -- Make sure changes are reflected on the configuration GUI 
%   VI121108A Vijay Iyer 12/11/08 -- Line period increments for different scan speeds are now powers-of-2
%   VI121108B Vijay Iyer 12/11/08 -- For now, don't allow fill fractions above .8192 -- this too greatly limits the allowable servo delay value for faster scans.
%   VI121708A Vijay Iyer 12/17/08 -- Significant changes based on new user-specified base zoom factor
%   VI121708B Vijay Iyer 12/17/08 -- For bidi scaning, max flyback rate should limit the slope computed from the scanAmplitude and the /active/ line period
%   VI122908A Vijay Iyer 12/29/08 -- Renamed maxFlybackRate to maxCommandSlope
%   VI122908B Vijay Iyer 12/29/08 -- Display nominal msPerLine as actually in milliseconds
%   VI123008A Vijay Iyer 12/30/08 -- state.internal.baseZoomFactor is now state.acq.baseZoomFactor, and its GUI callback should be invoked
%   VI123108A Vijay Iyer 12/31/08 -- Handle case where state.acq.baseFactor is infinite
%   VI010209A Vijay Iyer 1/2/09 -- Handle FF control display in a BiDi-scanning dependent manner
%   VI010609A Vijay Iyer 1/6/09 -- minZoomFactor property/concept has been eliminated; line period is adjustable instead 
%   VI010609B Vijay Iyer 1/6/09 -- Ensure the scan amplitude is in 0.1 increments
%   VI011609A Vijay Iyer 1/16/09 -- Remove the setting of the AO/AI rates here; leave this to INI file as well as new AO rate switching scheme
%
%% 
global state gh

%%%VI011609A: Removed %%%%%%%%%%%
% %Hard-code the AI/AO rates
% state.acq.inputRate = 1250000;
% updateGUIByGlobal('state.acq.inputRate');
% 
% state.acq.outputRate = 50000;
% updateGUIByGlobal('state.acq.outputRate')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

minLinePeriodIncrement = 1/gcd(state.acq.inputRate,state.acq.outputRate); %Can increment/decrement line period by 100us and still have integer # of AI/AO samples

if ~state.acq.bidirectionalScan 
    %VI031208A: Exclude fast scans if not bidirectional scanning 
    if state.acq.msPerLineGUI < state.init.minUnidirectionalLinePeriodGUI 
        state.acq.msPerLineGUI = state.init.minUnidirectionalLinePeriodGUI;
        updateGUIByGlobal('state.acq.msPerLineGUI');
    end
    %%%%%%%%%%%%%%
    
    %%VI010209A: Base zoom factor should follow sawtoothBaseZoomFactor
    state.acq.baseZoomFactor = state.acq.sawtoothBaseZoomFactor;
    updateGUIByGlobal('state.acq.baseZoomFactor');
    %%%%%%%%%%%%%%
end

%Determine parameters associated with selected line period
nominalLinePeriod = [];
linePeriodIncrement = [];
activeLinePeriod = [];
determineLinePeriodParams();

    function determineLinePeriodParams()        

        switch state.acq.msPerLineGUI % 1 = 1 ms, 2 = 2ms, 3 = 4 ms, 4 = 8 ms
            case 1
                state.acq.samplesAcquiredPerLine = 512;
                nominalLinePeriod = .5e-3;
                linePeriodIncrement = 1*minLinePeriodIncrement; %VI121108A Don't use linePeriodIncrement/2 as in the original version!
            case 2
                state.acq.samplesAcquiredPerLine = 1024;
                nominalLinePeriod = 1e-3;
                linePeriodIncrement = 2 * minLinePeriodIncrement; %VI031708A
            case 3
                state.acq.samplesAcquiredPerLine = 2048;
                nominalLinePeriod = 2e-3;
                linePeriodIncrement = 4 * minLinePeriodIncrement; %VI031708A, VI121108A
            case 4
                state.acq.samplesAcquiredPerLine = 4096;
                nominalLinePeriod = 4e-3;
                linePeriodIncrement = 8 * minLinePeriodIncrement; %VI031708A, VI121108A
            case 5
                state.acq.samplesAcquiredPerLine = 8192;
                nominalLinePeriod = 8e-3;
                linePeriodIncrement = 16 * minLinePeriodIncrement; %VI031708A, VI121108A
            otherwise
                error('The specified line period is greater than currently supported'); %VI010609A: This is an extreme edge case which should never practically be encountered
        end
        updateGUIByGlobal('state.acq.samplesAcquiredPerLine');

        activeLinePeriod = state.acq.samplesAcquiredPerLine/state.acq.inputRate;
    end

%%%VI121708A: Removed this approach%%%%%%
%zoomFactors = [1 2 3]; 
% incrementMultipliers = zeros(1,length(zoomFactors));
% numPosSlopePoints = zeros(1,length(zoomFactors)); %VI092808A
% for i=1:length(zoomFactors)
%     if i==1 || zoomFactors(i) <= state.internal.minZoomFactor
%         [incrementMultipliers(i) numPosSlopePoints(i)] = optimizeFillFrac(i); %VI092808A
%     else
%         incrementMultipliers(i) = incrementMultipliers(i-1);
%         numPosSlopePoints(i) = numPosSlopePoints(i-1); %VI092808A
%     end
% end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Ensure that zoom factor of 1 is supported at current amplitude and scan speed; otherwise, one must be adjusted
    function [incrementMultiplier numPosSlopePoints] = optimizeFillFrac(zoomFactor)

        numPosSlopePoints = [];
        minIncrementMultiplier = 0; %VI121108B
        maxIncrementMultiplier = 3;
        
        if state.acq.fastScanningX
            scanAmplitude = state.acq.scanAmplitudeX;
        else
            scanAmplitude = state.acq.scanAmplitudeY;
        end

        %while incrementMultiplier <= maxIncrementMultiplier
        incrementMultiplier = minIncrementMultiplier;
        while true
            totalIncrement = incrementMultiplier*linePeriodIncrement;
            if round(abs(totalIncrement/minLinePeriodIncrement)) - abs(totalIncrement/minLinePeriodIncrement) > 1e-10 %ensure that it rounds evenly, %VI120908A
                incrementMultiplier = incrementMultiplier+1;
                continue;
            end

            [fillFraction, linePeriod] = computeFillFrac(incrementMultiplier);
            numAOSamples = state.acq.outputRate * linePeriod; %guaranteed to be an integer, based on AO rate

            tooHigh = false;
            if ~state.acq.bidirectionalScan
                numPosSlopePoints = round(numAOSamples/(1+(2*abs(scanAmplitude)/zoomFactor)/(fillFraction*linePeriod*state.init.maxCommandSlope))); %VI122908A
                if numPosSlopePoints < round(fillFraction*numAOSamples)
                    tooHigh = true;
                end
            else
                numPosSlopePoints = numAOSamples;              
                slope = abs(2*scanAmplitude/zoomFactor)/activeLinePeriod; %VI121708B
                if slope > state.init.maxCommandSlope %VI122908A
                    tooHigh=true;
                end
            end

            if tooHigh
                if incrementMultiplier < maxIncrementMultiplier
                    incrementMultiplier = incrementMultiplier + 1;
                else
                    %%%VI010609A%%%%%%
                    incrementMultiplier = inf;
                    numPosSlopePoints = inf;
                    break;
                    %%%%%%%%%%%%%%%%%%
                end
            else
                break; %found the optimum FF!
            end

        end
        %%%VI010609A: Removed %%%%%%%%%%
        %         %Handle case where zoom was adjusted, i.e. couldn't satisfy max flyback rate with available FFs
        %         if adjZoom
        %             state.internal.minZoomFactor = zoomFactor;
        %         end
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    end

if isinf(optimizeFillFrac(1))
    resp = questdlg(['Exceeded max flyback rate with min fill fraction at current scan amplitude.' sprintf('\n') 'Shall we reduce the scan amplitude or reduce the scan speed?'], ...
        'Scan Amplitude Too High', 'Reduce Amplitude', 'Reduce Scan Speed','Reduce Amplitude');
    switch resp
        %%%VI010609A: Removed %%%%%%%%%%%%%%
        %         case 'Clamp Zoom'
        %             %state.acq.baseZoomFactor = max([state.acq.baseZoomFactor state.internal.minZoomFactor]); %VI123008A
        %             %updateGUIByGlobal('state.acq.baseZoomFactor', 'Callback', 1); %VI123008A
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
        case 'Reduce Scan Speed'
            while true                
                state.acq.msPerLineGUI = state.acq.msPerLineGUI + 1;
                determineLinePeriodParams();
                if ~isinf(optimizeFillFrac(1))
                    break;
                end
            end
            
            updateGUIByGlobal('state.acq.msPerLineGUI');
        case 'Reduce Amplitude'
            while true
                %Adjust scan amplitude, while preserving fill fraction 
                aspectRatio = state.acq.scanAmplitudeY / state.acq.scanAmplitudeX;
                if state.acq.fastScanningX
                    state.acq.scanAmplitudeX = adjustScanAmplitude(state.acq.scanAmplitudeX);
                    state.acq.scanAmplitudeY = state.acq.scanAmplitudeX * aspectRatio;
                else
                    state.acq.scanAmplitudeY = adjustScanAmplitude(state.acq.scanAmplitudeY);
                    state.acq.scanAmplitudeX = state.acq.scanAmplitudeY / aspectRatio;
                end
                
                if ~isinf(optimizeFillFrac(1))
                    break;
                end
            end
            
            updateGUIByGlobal('state.acq.scanAmplitudeX');
            updateGUIByGlobal('state.acq.scanAmplitudeY');
    end

end
    function newAmplitude = adjustScanAmplitude(oldAmplitude)

        if state.acq.bidirectionalScan
            newAmplitude = fix(10 * sign(oldAmplitude) * activeLinePeriod * state.init.maxCommandSlope / 2) / 10; %VI122908A, VI010609B
        else
            newAmplitude = sign(oldAmplitude) * (abs(oldAmplitude) - 0.1);
        end
    end

%Determine FF and msPerLine at all required zoom factors
if isinf(state.acq.baseZoomFactor) %VI123108A
    zoomFactors = 1:state.internal.maxBaseZoomFactor; %VI123108A, VI010609A
else
    zoomFactors = 1:state.acq.baseZoomFactor; %VI123008A, VI010609A
end

incrementMultipliers = zeros(length(zoomFactors),1);
numPosSlopePoints = zeros(length(zoomFactors),1);
for i=1:length(zoomFactors)
    [incrementMultipliers(i) numPosSlopePoints(i)] = optimizeFillFrac(zoomFactors(i));
end
%%%VI123108A%%%%%%%%%%%
if isinf(state.acq.baseZoomFactor)    
    if length(incrementMultipliers) > 2 && ...
            incrementMultipliers(end) ~= incrementMultipliers(end-1) 
        msgbox('Unable to optimize fill fraction for all zoom levels. Reset Base Zoom Factor.');
        state.acq.baseZoomFactor = state.internal.maxBaseZoomFactor;
        updateGUIByGlobal('state.acq.baseZoomFactor','Callback',1);
        setAcquisitionParameters();
        return;
    end       
end
%%%%%%%%%%%%%%%%%%%%%%%
[state.internal.fillFractionArray state.internal.msPerLineArray] = computeFillFrac(incrementMultipliers);
state.internal.posSlopePointsArray = numPosSlopePoints; %VI092808A

    function [fillFraction,linePeriod] = computeFillFrac(incrementMultiplier)
        linePeriod = nominalLinePeriod + incrementMultiplier*linePeriodIncrement;
        fillFraction = activeLinePeriod./linePeriod;
    end 

%Determine nominal fill fraction and msPerLine
state.acq.nominalFillFraction = state.internal.fillFractionArray(end);
updateGUIByGlobal('state.acq.nominalFillFraction');
set(gh.basicConfigurationGUI.etNominalMsPerLine,'String',num2str(1000 * state.internal.msPerLineArray(end))); %VI122908B

%%%VI010209A: Display nominal FF and msPerLine as either active or not, depending on whether bidi scanning is enabled 
nominalFFControls = {'stBaseZoomFactorDescription2' 'stBaseZoomFactor' 'etNominalFillFrac' 'etNominalMsPerLine'};
if state.acq.bidirectionalScan
    controlsEnabled = 'off';
else
    controlsEnabled = 'on';
end
for i=1:length(nominalFFControls)
    set(gh.basicConfigurationGUI.(nominalFFControls{i}),'Enable',controlsEnabled);
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%VI121708A: Following no longer needed%%%%%%%
% %Caches FF and Line Period values for zoom=1,2,& 3
% [state.internal.fillFractionArray state.internal.msPerLineArray] = computeFillFrac(incrementMultipliers); 
% state.internal.posSlopePointsArray = numPosSlopePoints; %VI092808A
% 
% %Determine 'base zoom factor'--the lowest zoom at which the FF is constant for it and all higher zooms
% fillFracSteps = find(diff(state.internal.fillFractionArray));
% if ~isempty(fillFracSteps)
%     state.internal.baseZoomFactor = fillFracSteps(1);    
% else
%     state.internal.baseZoomFactor = state.internal.minZoomFactor; 
% end
% updateGUIByGlobal('state.internal.baseZoomFactor'); %VI121008A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Computes current FF and Line Period based on current zoom
updateZoom;    

%Determines Pixel Time & Bin Factor based on current parameters
updatePixelTime; 
updateBinFactor;




        
% % %Determine number of increments to adjust line period by, away from nominalMSPerLine, based on Fill Fraction parameter 
% % switch state.acq.fillFractionGUI
% % 	case 1 % fillFraction = 0.71234782608696        
% %         incrementMultiplier = 3;
% % 	case 2 % fillFraction =  0.74472727272727
% %         incrementMultiplier = 2;
% % 	case 3 % fillFraction = 0.78019047619048
% %         incrementMultiplier = 1;
% % 	case 4 % fillFraction = 0.81920000000000
% %         incrementMultiplier = 0;
% % 	case 5 % fillFraction = 0.86231578947368
% %         incrementMultiplier = -1;
% % 	case 6 % fillFraction = 0.91022222222222
% %         incrementMultiplier = -2;
% % 	case 7 % fillFraction = 0.96376470588235
% %         incrementMultiplier = -3;
% % end
% 
% %Compute actual line period value implied by selected fill fraction, after validating that choice is valid (and adjusting if not)
% totalIncrement = incrementMultiplier*linePeriodIncrement;
% % %Ensure total increment is an integer number of the minimum increment (practically--this fixes the 1ms/line problem with original logic)
% % while abs(round(totalIncrement/minLinePeriodIncrement) - (totalIncrement/minLinePeriodIncrement)) > 1e-10 %Don't know any other way to test for clean divisibility
% %     totalIncrement = totalIncrement-sign(totalIncrement)*linePeriodIncrement;
% %     done = adjustFillFracGUI(5); %adjust towards the "default" fill fraction (.8192)
% %     if done
% %         break;
% %     end
% % end
% 
% computeFillFrac = @(activeLinePeriod,nominalLinePeriod,totalIncrement) activeLinePeriod/(nominalLinePeriod+totalIncrement);
% fillFraction = computeFillFrac(activeLinePeriod,nominalLinePeriod,totalIncrement);
% nominalFillFraction = computeFillFrac(.8192*2e-3,2e-3,5*minLinePeriodIncrement*incrementMultiplier); %VI092408A: For now, base nominal fill frac on 2ms/line specific case
% %%%%VI091808A
% % %Ensure that fractional line delay is smaller than (1-fillFraction)
% % while ~isValidFillFrac(fillFraction) %VI031308A
% %     totalIncrement = totalIncrement + linePeriodIncrement; 
% %     fillFraction = computeFillFrac(activeLinePeriod,nominalLinePeriod,totalIncrement);
% %     done = adjustFillFracGUI(1); %adjust towards the smallest fill fraction
% %     if done
% %         break;
% %     end
% % end
% %%%%%%%%%%%%%%%%%%%%
% 
% %Update GUI/state parameters
% updateGUIByGlobal('state.acq.fillFractionGUI');
% 
% state.acq.nominalFillFraction = nominalFillFraction; %VI092408A
% updateGUIByGlobal('state.acq.nominalFillFraction'); %VI092408A
% state.acq.fillFraction = fillFraction;
% updateGUIByGlobal('state.acq.fillFraction');
% state.acq.msPerLine = nominalLinePeriod+totalIncrement;
% updateGUIByGlobal('state.acq.msPerLine');
% setStatusString(['Fill frac = ' num2str(fillFraction,'%0.4f')]);
% %state.internal.lineDelay = state.acq.lineDelay; %VI031708B %VI091808A

end

%Function adjusts state.acq.fillFractionGUI value towards a specified "target" value , incrementing or decrementing by one
function done = adjustFillFracGUI(target)

global state

if state.acq.fillFractionGUI > target
    state.acq.fillFractionGUI = state.acq.fillFractionGUI - 1;
    done = false;
elseif state.acq.fillFractionGUI < target
    state.acq.fillFractionGUI = state.acq.fillFractionGUI + 1;
    done = false;
else
    fprintf(2,'None of the available fill fraction values can be reconciled with the current line/cusp delay values. Adjust those values.\n');
    done = true;
end

end

%Function checks whether fill fraction is consistent with other parameters
function logval = isValidFillFrac(fillFraction)
global state

if (1-fillFraction) < state.acq.lineDelay && ~state.acq.bidirectionalScan
    logval=false;
else
    logval=true;
end

end  
     
% function minIncrement = getMinLinePeriodIncrement()
% global state
% 
% commonRate = gcd(state.acq.inputRate,state.acq.outputRate);
% 
% if commonRate > 1
%     minIncrement = 1/commonRate;
% else %could either be a perfect match...or hopeless
%     minIncrement = 0
% end
%     
    
   




%% ORIGINAL VERSION
% global state gh
% 
% % setAcquisitionParameter.m****
% % Function that sets the samplesAcquiredPerLine and inputRate when the user sets the 
% % Fillfractiona dn the msPerLine.
% 
% state.acq.inputRate = 1250000;
% updateGUIByGlobal('state.acq.inputRate');
% 		
% switch state.acq.msPerLineGUI % 1 = 1 ms, 2 = 2ms, 3 = 4 ms, 4 = 8 ms
% case 1
% 	state.acq.samplesAcquiredPerLine = 1024;
% 	updateGUIByGlobal('state.acq.samplesAcquiredPerLine');
% 	state.acq.outputRate = 40000;
% 	updateGUIByGlobal('state.acq.outputRate');
% 		
% 	switch state.acq.fillFractionGUI
% 	case 1 % fillFraction = 0.71234782608696
% 		state.acq.fillFraction =0.71234782608696;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .0011500;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 2 % fillFraction =  0.74472727272727
% 		state.acq.fillFraction = 0.7447272727272720000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00110;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 3 % fillFraction = 0.78019047619048
% 		state.acq.fillFraction = 0.7801904761904800000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .0010500;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 4 % fillFraction = 0.81920000000000
% 		state.acq.fillFraction = 0.8192000000000000000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .0010;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 5 % fillFraction = 0.81920000000000
% 		state.acq.fillFraction = 0.8192000000000000000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.fillFractionGUI = 4;
% 		updateGUIByGlobal('state.acq.fillFractionGUI');
% 		state.acq.msPerLine = .0010;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('Fill Fraction = .8192');
% 	case 6 % fillFraction = 0.81920000000000
% 		state.acq.fillFraction = 0.8192000000000000000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.fillFractionGUI = 4;
% 		updateGUIByGlobal('state.acq.fillFractionGUI');
% 		state.acq.msPerLine = .0010;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('Fill Fraction = .8192');
% 	case 7 % fillFraction = 0.81920000000000
% 		state.acq.fillFraction = 0.8192000000000000000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.fillFractionGUI = 4;
% 		updateGUIByGlobal('state.acq.fillFractionGUI');
% 		state.acq.msPerLine = .0010;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('Fill Fraction = .8192');
% 		
% 	otherwise 
% 	end
% 	
% case 2
% 	state.acq.samplesAcquiredPerLine = 2048;
% 	updateGUIByGlobal('state.acq.samplesAcquiredPerLine');
% 	state.acq.outputRate = 40000;
% 	updateGUIByGlobal('state.acq.outputRate');
% 	
% 	switch state.acq.fillFractionGUI
% 	case 1 % fillFraction = 0.71234782608696
% 		state.acq.fillFraction = 0.71234782608696;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00230;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 2 % fillFraction =  0.74472727272727
% 		state.acq.fillFraction = 0.74472727272727;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00220;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 3 % fillFraction = 0.78019047619048
% 		state.acq.fillFraction = 0.78019047619048;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00210;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 4 % fillFraction = 0.81920000000000
% 		state.acq.fillFraction = 0.81920000000000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .0020;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 5 % fillFraction = 0.86231578947368
% 		state.acq.fillFraction = 0.86231578947368;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00190;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 6 % fillFraction = 0.91022222222222
% 		state.acq.fillFraction = 0.91022222222222;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00180;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('');
% 	case 7  % fillFraction = 0.91022222222222
% 		state.acq.fillFraction = 0.91022222222222;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.fillFractionGUI = 6;
% 		updateGUIByGlobal('state.acq.fillFractionGUI');
% 		state.acq.msPerLine = .00180;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		setStatusString('Fill Fraction = .9102');
% 		
% 	otherwise 
% 	end
% 	
% case 3
% 	
% 	setStatusString('');
% 	state.acq.samplesAcquiredPerLine = 4096;
% 	updateGUIByGlobal('state.acq.samplesAcquiredPerLine');
% 	state.acq.outputRate = 40000;
% 	updateGUIByGlobal('state.acq.outputRate');
% 		
% 	switch state.acq.fillFractionGUI
% 	case 1 % fillFraction = 0.71234782608696
% 		state.acq.fillFraction = 0.71234782608696;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00460;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 2 % fillFraction =  0.74472727272727
% 		state.acq.fillFraction = 0.74472727272727;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00440;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 3 % fillFraction = 0.78019047619048
% 		state.acq.fillFraction = 0.78019047619048;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00420;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 4 % fillFraction = 0.81920000000000
% 		state.acq.fillFraction = 0.81920000000000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00400;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 5 % fillFraction = 0.86231578947368
% 		state.acq.fillFraction = 0.86231578947368;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00380;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 6 % fillFraction = 0.91022222222222
% 		state.acq.fillFraction = 0.91022222222222;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00360;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 7  % fillFraction = 0.96376470588235
% 		state.acq.fillFraction = 0.96376470588235;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .003400;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 		
% 	otherwise 
% 	end
% 	
% case 4
% 	setStatusString('');
% 	state.acq.samplesAcquiredPerLine = 8192;
% 	updateGUIByGlobal('state.acq.samplesAcquiredPerLine');
% 	state.acq.outputRate = 40000;
% 	updateGUIByGlobal('state.acq.outputRate');
% 	
% 	switch state.acq.fillFractionGUI
% 	case 1 % fillFraction = 0.71234782608696
% 		state.acq.fillFraction = 0.71234782608696;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00920;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 2 % fillFraction =  0.74472727272727
% 		state.acq.fillFraction = 0.74472727272727;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00880;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 3 % fillFraction = 0.78019047619048
% 		state.acq.fillFraction = 0.78019047619048;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00840;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 4 % fillFraction = 0.81920000000000
% 		state.acq.fillFraction = 0.81920000000000;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .0080;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 5 % fillFraction = 0.86231578947368
% 		state.acq.fillFraction = 0.86231578947368;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00760;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 6 % fillFraction = 0.91022222222222
% 		state.acq.fillFraction = 0.91022222222222;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .00720;
% 		updateGUIByGlobal('state.acq.msPerLine');
% 	case 7  % fillFraction = 0.96376470588235
% 		state.acq.fillFraction = 0.96376470588235;
% 		updateGUIByGlobal('state.acq.fillFraction');
% 		state.acq.msPerLine = .006800;
% 		updateGUIByGlobal('state.acq.msPerLine');
%     end
% end

    

