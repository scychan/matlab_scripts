function y = makeSawtoothY(t, scanOffsetY, scanAmplitudeY)
%% function y = makeSawtoothY(t, scanOffsetY, scanAmplitudeY)
% Function that defines the frame scanning mirror output.
%
%% CREDITS
% Written by: Thomas Pologruto
% Cold Spring Harbor Labs
% February 9, 2001
%% NOTES
%   This function computes the scanAmplitude after accounting for the zoom factor, but this is not needed as the caller has already ensured that Zoom=1 for the purpose of this calculation
%
%% CHANGES
%   VI071508A Vijay Iyer 7/15/2008 -- Handle bidirectional case differently
%   VI071508B Vijay Iyer 7/15/2008 -- For bidirectional case, account for the X fill fraction...
%   VI091708A Vijay Iyer 9/17/2008 -- Compute final sawtooth waveform directly here, rather than in makeMirrorDataOutputY
%   VI091808A Vijay Iyer 9/18/2008 -- Don't compute lineDelay here
%   VI092208A Vijay Iyer 9/22/2008 -- Don't employ actual amplitude/zoom factor within this function anymore
%   VI010609B Vijay Iyer 1/07/2009 -- minZoomFactor property/concept has been eliminated
%% ************************************************************************

global state

%state.internal.lineDelay = .001*state.acq.lineDelay/state.acq.msPerLine; %VI091808A

% Parameter that define the scan and flyback functions for the y channel(frame scanning mirror).
%state.internal.scanAmplitudeY = scanAmplitudeY/state.acq.zoomFactor; %VI092208A

% if ~state.acq.bidirectionalScan %VI071508A
%     slopex1 = 2*state.internal.scanAmplitudeX/(state.acq.msPerLine*state.acq.fillFraction);
%     
%     
%     flybackDecimal = (1-state.acq.fillFraction-state.internal.lineDelay);
%     
%     slopey1 = ((2*state.internal.scanAmplitudeY)/(state.acq.msPerLine*(state.acq.linesPerFrame - flybackDecimal)));
%     intercepty1 = (scanOffsetY - state.internal.scanAmplitudeY);
%     slopey2 =  (-(2*state.internal.scanAmplitudeY)/(state.acq.msPerLine*flybackDecimal));
%     intercepty2 = ((2*state.internal.scanAmplitudeY*(state.acq.linesPerFrame-flybackDecimal))/(flybackDecimal)) + (scanOffsetY + state.internal.scanAmplitudeY);
%     
%     numberOfPositiveSlopePointsY = round((state.acq.linesPerFrame-flybackDecimal)*state.internal.lengthOfXData );		% %VI091708A: Number of data points for positive slope on y channel
% else
    
    %state.internal.scanAmplitudeY = state.internal.scanAmplitudeY*state.acq.fillFraction; %VI071508B, VI092208A
    %scanAmplitudeY = scanAmplitudeY/state.internal.minZoomFactor; %VI092208A, VI010609A
    
    %slopey1 = (2*state.internal.scanAmplitudeY)/(state.acq.msPerLine*(state.acq.linesPerFrame-1));
    slopey1 = (2*scanAmplitudeY)/(state.acq.msPerLine*(state.acq.linesPerFrame-1)); %VI092208A
    %intercepty1 = scanOffsetY - state.internal.scanAmplitudeY;
    intercepty1 = scanOffsetY - scanAmplitudeY; %VI092208A
    
    %slopey2 = -(2*state.internal.scanAmplitudeY)/state.acq.msPerLine; %flyback in the time it takes for one line
    slopey2 = -(2*scanAmplitudeY)/state.acq.msPerLine; %flyback in the time it takes for one line
    %intercepty2 = scanOffsetY + state.internal.scanAmplitudeY;
    intercepty2 = scanOffsetY + scanAmplitudeY;
    
    numberOfPositiveSlopePointsY = (state.acq.linesPerFrame-1)*state.internal.lengthOfXData; %VI091708A
% end

y1 = slopey1*t + intercepty1;
if ~state.acq.bidirectionalScan %VI080608A
    y2 = slopey2*t + intercepty2;
else
    y2 = slopey2*(t-(state.acq.msPerLine*(state.acq.linesPerFrame-1))) + intercepty2;
end

y = [y1(1:numberOfPositiveSlopePointsY)'; y2(numberOfPositiveSlopePointsY+1:end)']; %VI091708A
    