function x = makeSawtoothX(t, scanOffsetX, scanAmplitudeX);
%% function x = makeSawtoothX(t, scanOffsetX, scanAmplitudeX);
% Function that defines the line scanning mirror output.
%% 
% Written by: Thomas Pologruto
% Cold Spring Harbor Labs
% February 9, 2001
%
%% NOTES
%   
%% MODIFICATIONS
%   VI022608A Vijay Iyer 2/26/08 -- Handled bidirectional scanning case
%   VI091708A Vijay Iyer 9/17/08 -- Compute final sawtooth waveform directly here, rather than in makeMirrorDataOutputX
%   VI091808A Vijay Iyer 9/18/08 -- Adjust zoom factor if the specified fillFraction cannot be achieved for given scanAmplitude
%   VI091808B Vijay Iyer 9/18/08 -- Compute line delay parameter based on centering scan within upward slope
%   VI091808C Vijay Iyer 9/18/08 -- Handle bidi scanning correctly again
%   VI092108A Vijay Iyer 9/21/08 -- Compute # of positive points working with internal.minZoomFactor, rather than the actual acq.zoomFactor
%   VI092208A Vijay Iyer 9/22/08 -- Don't employ actual amplitude/zoom factor within this function anymore
%   VI092808A Vijay Iyer 9/28/08 -- Computation and use of fillFraction/posSlopePoints is now done elsewhere. The values are applied here based on current zoom factor. 
%   VI120908A Vijay Iyer 12/09/08 -- Complete seeming intention of VI092808A
%   VI122908A Vijay  Iyer 12/29/08 -- Renamed maxFlybackRate to maxCommandSlope
%   VI011209A Vijay Iyer 1/09/08 -- Ensure that line delay consists of even # of AO points
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
global state

%state.internal.lineDelay = .001*state.acq.lineDelay/state.acq.msPerLine; %I don't understand why one divides (rather than multiplies) by state.acq.msPerLine (Vijay Iyer)

% Parameter that define the scan and flyback functions for the x channel(line scanning mirror).
%state.internal.scanAmplitudeX = scanAmplitudeX/state.acq.zoomFactor; %VI092208A
state.internal.lengthOfXData = length(t); %VI091708A
%state.internal.minZoomFactor = 1; %VI092808A


%TPMOD 2/6/02
%newDelay = .001*state.acq.cuspDelay/state.acq.msPerLine;
    
    %%%VI091808A/VI092808A%%%%%%%%%%%%
%     function computeNumberOfPositiveSlopePoints
%         %numberOfPositiveSlopePoints = round(state.internal.lengthOfXData/(1+(2*abs(state.internal.scanAmplitudeX))/(state.acq.fillFraction*state.acq.msPerLine*state.init.maxFlybackRate)));
%         numberOfPositiveSlopePoints = round(state.internal.lengthOfXData/(1+(2*abs(scanAmplitudeX)/state.internal.minZoomFactor)/(state.acq.fillFraction*state.acq.msPerLine*state.init.maxFlybackRate)));
% %         if mod(numberOfPositiveSlopePoints,2) %odd #
% %             numberOfPositiveSlopePoints = numberOfPositiveSlopePoints - 1; %add extra point to flyback
% %         end
%     end
%     %%%%%%%%%%%%%%%%%%%%%%%%

if ~state.acq.bidirectionalScan %VI022608A
    %flybackDecimal = (1 - state.acq.fillFraction - state.internal.lineDelay + newDelay);       
        
    %     %%%VI091808A/VI092808A%%%%%%%%%%%%%%%
    %     minZoomAdjusted = false;
    %     while true
    %
    %         computeNumberOfPositiveSlopePoints();
    %
    %         if numberOfPositiveSlopePoints < round(state.acq.fillFraction*state.internal.lengthOfXData)
    %             minZoomAdjusted = true;
    %             state.internal.minZoomFactor =  state.internal.minZoomFactor + 1; %VI092108A
    %             %state.internal.scanAmplitudeX = scanAmplitudeX/state.internal.minZoomFactor; %VI092108A VI092208A
    %         else
    %             break;
    %         end
    %     end
    
    %%VI092208A: Moved to makeMirrorData Output
    %     if minZoomAdjusted
    %         if state.acq.zoomFactor < state.internal.minZoomFactor %VI092108A
    %             state.acq.zoomFactor = state.internal.minZoomFactor;
    %             updateZoomStrings;
    %             beep;
    %             fprintf(2,'WARNING: Requested scan exceeded servo flyback rate maximum. Zoom factor was increased. Consider reducing scan amplitude or fill fraction.\n');
    %             setStatusString('Adjusted Zoom!');
    %         end
    %     end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    slopex1 = 2*scanAmplitudeX/(state.acq.msPerLine*state.acq.fillFraction); %VI092108A
    slopex2 = -sign(scanAmplitudeX)*state.init.maxCommandSlope; %VI122908A
        
    interceptx1 = scanOffsetX - (state.internal.numPosSlopePoints*state.acq.msPerLine/state.internal.lengthOfXData)*slopex1/2;
    
    x = zeros(state.internal.lengthOfXData,1);
    x(1:state.internal.numPosSlopePoints) = slopex1*t(1:state.internal.numPosSlopePoints) + interceptx1;
    x(state.internal.numPosSlopePoints+1:end) = x(state.internal.numPosSlopePoints) + slopex2 * (t(state.internal.numPosSlopePoints+1:end)-t(state.internal.numPosSlopePoints));    
    
%%%THE OLD WAY    
%     slopex1 = ((2*state.internal.scanAmplitudeX)/(state.acq.msPerLine*(1-flybackDecimal)));
%     interceptx1 = (scanOffsetX - state.internal.scanAmplitudeX);
%     slopex2 = (-(2*state.internal.scanAmplitudeX)/(state.acq.msPerLine*flybackDecimal));
%     interceptx2 = ((1-flybackDecimal)/(flybackDecimal))*(2*state.internal.scanAmplitudeX) + (scanOffsetX + state.internal.scanAmplitudeX);
    
%    numberOfPositiveSlopePoints = round((1-flybackDecimal)*state.internal.lengthOfXData ); %VI091708A
%%%%%%%%%%%%


else      
    %slopex1 = (2*state.internal.scanAmplitudeX)/(state.acq.msPerLine*state.acq.fillFraction); %VI091808C 
    slopex1 = (2*scanAmplitudeX)/(state.acq.msPerLine*state.acq.fillFraction); %VI091808C, VI092208A
    slopex2 = -slopex1;
    %interceptx1 = scanOffsetX - (state.internal.scanAmplitudeX/state.acq.fillFraction);%VI091808C
    %interceptx2 = scanOffsetX + (state.internal.scanAmplitudeX/state.acq.fillFraction);%VI091808C 
    interceptx1 = scanOffsetX - (scanAmplitudeX/state.acq.fillFraction);%VI091808C
    interceptx2 = scanOffsetX + (scanAmplitudeX/state.acq.fillFraction);%VI091808C

    
    x1 = slopex1*t + interceptx1;
    x2 = slopex2*t + interceptx2;

    x = [x1'; x2']; %VI091708A
    
    %numberOfPositiveSlopePoints = length(t); %VI120908A %VI091808B %should be even...
    
end

%%%%%VI091808B%%%%%%%
acqSamples = round(state.internal.lengthOfXData*state.acq.fillFraction);
if mod(state.internal.numPosSlopePoints - acqSamples,2) %VI011209A: Ensure that number of samples pertaining to line delay is even
    acqSamples = acqSamples + 1;
end
%state.internal.lineDelay = (numberOfPositiveSlopePoints - acqSamples)/(2*state.internal.lengthOfXData); %VI120908A
state.internal.lineDelay = (state.internal.numPosSlopePoints - acqSamples)/(2*state.internal.lengthOfXData); %VI120908A
%%%%%%%%%%%%%%%%%%%%%%

end
